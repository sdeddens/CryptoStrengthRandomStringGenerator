using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics;


namespace SecretStringMaker
{
    /// <summary>
    ///     A tool designed to inspect secrets generated by getNewSecret.  The tool
    ///     runs getNewSecret multiple times and tabulates the location in the secret
    ///     where each character is placed.  Any recurring clumping of a particular
    ///     character's totals or location is a sign of a flawed secrets generator.
    /// </summary>
    public class TestRunner
    {

        /// <summary>
        ///     
        /// </summary>
        /// <param name="repetitions">Number of test strings to generate</param>
        public void runTest(int repetitions = 100, int secretStringLength = 92)
        {
            string secret = null;
            double average;
            double squareDiffsTotal;
            int charIndex;

            var stopWatch = new Stopwatch();
            var maker = new SecretMaker(secretStringLength);

            // Create and initialize the lookup table
            var lookupTable = new Dictionary<char, int>(SecretMaker.allCharsPool.Length);

            for (int i = 0; i < SecretMaker.allCharsPool.Length; i++)
            {
                lookupTable[SecretMaker.allCharsPool[i]] = i;
            }

            // Create the char use totalizer.
            int[] charUseTotalizer = new int[SecretMaker.allCharsPool.Length];

            // Create the distribution totalizer jagged array structure: The base array represents
            // the secret string and each sub-array represents the allCharsPool. The value in a
            // sub-array cell is the total times a specific char from the allCharsPool appeared at
            // that location in a generated secret string.
            int[][] distributionTotalizer = new int[SecretMaker.allCharsPool.Length][];

            for (int i = 0; i < distributionTotalizer.Length; i++)
            {
                distributionTotalizer[i] = new int[secretStringLength];
            }

            // Repetitively generate and tally the data.
            for (int i = 0; i < repetitions; i++)
            {
                // Generate the data.
                stopWatch.Start();
                secret =  maker.getNewSecret();
                stopWatch.Stop();

                // Tally the data.
                for (int j = 0; j < secret.Length; j++)
                {
                    charIndex = lookupTable[secret[j]];
                    charUseTotalizer[charIndex]++;
                    distributionTotalizer[charIndex][j]++;
                }
            }

            // Calculate the statistics.
            var charAverage = charUseTotalizer.Average();
            squareDiffsTotal = charUseTotalizer.Select(val => (val - charAverage) * (val - charAverage)).Sum();
            double charDeviation = Math.Sqrt(squareDiffsTotal / charUseTotalizer.Length);

            double[] locationDeviations = new double[SecretMaker.allCharsPool.Length];
            for (int i = 0; i < SecretMaker.allCharsPool.Length; i++)
            {
                average = distributionTotalizer[i].Average();
                squareDiffsTotal = distributionTotalizer[i].Select(val => (val - average) * (val - average)).Sum();
                locationDeviations[i] = Math.Sqrt(squareDiffsTotal / charUseTotalizer.Length);
            }

            var locDevAverage = locationDeviations.Average();
            squareDiffsTotal = locationDeviations.Select(val => (val - locDevAverage) * (val - locDevAverage)).Sum();
            double deaviationsOfTheDeviations = Math.Sqrt(squareDiffsTotal / locationDeviations.Length);

            // Write the statistics to the console.
            Console.WriteLine(
                $"\n allCharsPool: (Length: {SecretMaker.allCharsPool.Length} chars)\n {SecretMaker.allCharsPool}\n" +
                $"\n Last Secret Generated: (Length: {secret.Length})\n {secret}\n\n" +
                $" Number of secret strings generated: {repetitions}\n" +
                $" Char occurrence average: {charAverage:f2}; " +
                $" Char occurrence standard deviation: {charDeviation:f2}\n\n" +
                $" Each character's deviation from the average:");

            for (int i = 0; i < charUseTotalizer.Length; i++)
            {
                if (i % 10 == 0)
                {
                    Console.Write("\n ");
                }
                Console.Write($"{SecretMaker.allCharsPool[i]}: {pad(charUseTotalizer[i] - (int)charAverage)}{(charUseTotalizer[i] - charAverage).ToString("+0;-#")}   ");
            }

            Console.WriteLine(
                $"\n\n Char loc ave of std devs: {locDevAverage:f3}  " +
                $"Standard deviation of the deviations: {deaviationsOfTheDeviations:f3}\n" +
                $" Standard Deviation of each char's position in secrets:");

            for (int i = 0; i < locationDeviations.Length; i++)
            {
                if (i % 10 == 0)
                {
                    Console.Write("\n ");
                }
                Console.Write($"{SecretMaker.allCharsPool[i]}:{pad((int)locationDeviations[i])}{locationDeviations[i]:0.000}   ");
            }

            Console.WriteLine($" RunTime: {stopWatch.Elapsed}");
        }

        /// <summary>
        ///     Quick and dirty little formatting helper.
        /// </summary>
        /// <param name="value">number of characters to print</param>
        /// <returns></returns>
        private string pad(int value)
        {
            value = Math.Abs(value);
            int size = (value == 0) ? 1 : (int)Math.Floor(Math.Log10(value) + 1);
            switch (1 - size)
            {
                case -1: return " ";
                case 0: return "  ";
                default: return "";
            }
        }
    }
}
